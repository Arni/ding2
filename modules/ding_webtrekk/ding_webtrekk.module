<?php
/**
 * @file
 * Include basic hooks for the module functionality.
 */

/**
 * Implements hook_menu().
 */
function ding_webtrekk_menu() {
  $items = [];
  $items['admin/config/ding/webtrekk'] = [
    'title' => 'Webtrekk',
    'description' => 'Settings for the Webtrekk analytics tool.',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['ding_webtrekk_admin_settings_form'],
    'access arguments' => ['administer site configuration'],
    'file' => 'ding_webtrekk.admin.inc',
  ];

  return $items;
}

/**
 * Implements hook_page_alter().
 */
function ding_webtrekk_page_alter(&$page) {
  $domain = variable_get('webtrekk_ti_domain', '');
  $id = variable_get('webtrekk_ti_id', '');

  if (empty($domain) && empty($id)) {
    return;
  }

  // @codingStandardsIgnoreStart
  $tag_integration_logic = '/** start TagIntegration loader  */
(function(c,d,a,f){c.wts=c.wts||[];var g=function(b){var a="";b.customDomain&&b.customPath?a=b.customDomain+"/"+b.customPath:b.tiDomain&&b.tiId&&(a=b.tiDomain+"/resp/api/get/"+b.tiId+"?url="+encodeURIComponent(c.location.href)+"&v=5");if(b.option)for(var d in b.option)a+="&"+d+"="+encodeURIComponent(b.option[d]);return a};if(-1===d.cookie.indexOf("wt_r=1")){var e=d.getElementsByTagName(a)[0];a=d.createElement(a);a.async=!0;a.onload=function(){if("undefined"!==typeof c.wt_r&&!isNaN(c.wt_r)){var b=new Date,a=b.getTime()+1E3*parseInt(c.wt_r);b.setTime(a);d.cookie="wt_r=1;path=/;expires="+b.toUTCString()}};a.onerror=function(){"undefined"!==typeof c.wt_mcp_hide&&"function"===typeof c.wt_mcp_hide.show&&(c.wt_mcp_hide.show(),c.wt_mcp_hide.show=function(){})};a.src="//"+g(f);e.parentNode.insertBefore(a,e)}})(window,document,"script",_tiConfig);
/** end TagIntegration loader */';
  // @codingStandardsIgnoreEnd

  $page['page_bottom']['webtrekk']['#attached']['js'] = [
    [
      'data' => 'window._tiConfig = window._tiConfig || {
        tiDomain: ' . "'$domain'," .
        'tiId: ' . "'$id'," .
        'option: {}
      };' . $tag_integration_logic,
      'type' => 'inline',
      'scope' => 'footer',
    ],
  ];

  // Here we collect and add the general page parameters that aren't dependant
  // on data and timing from a specific hook implementation.
  $params = [];

  // Tracks whether the user is logged in and, if logged in, what login provider
  // was used.
  if (user_is_logged_in()) {
    // Note that this separation of logged in users might be problematic if some
    // pages are also cached for authenticated users.
    if (module_exists('ding_gatewayf') && _ding_gatewayf_is_logged_in_with_gatewayf()) {
      $params['p_isloggedin'] = 'NemId';

      // This is the landing page for successful user registration with gatewayf.
      // If the registration was successful, the users will be automatically
      // logged in. So by also requiring a logged in user before setting parameter
      // we reduce the chances of false positives. For example, it will prevent
      // random access to the URL from anonymous users, from being tracked.
      if (strpos(current_path(), DING_GATEWAYF_REGISTRATION_SUCCESS_URL) === 0) {
        $params['p_usercreate'] = 'NemId';
      }
    }
    // Fallback to cpr+pin if none the modules we know about was used to log in.
    else {
      $params['p_isloggedin'] = 'cpr+pinkode';
    }

  }

  // Track ting search results. We take advantage of the fact that ting_search
  // module stores the result in a static variable when search is triggered via
  // search_data() function from core search module. Since this is not tied to
  // any path, we also check current_path().
  if (strpos(current_path(), 'search/ting') === 0) {
    if ($search_result = ting_search_current_results()) {
      $params += [
        'OSS' => $search_result->getSearchRequest()->getFullTextQuery(),
        'OSSr' => $search_result->getNumTotalObjects(),
      ];

      // We want to track facets that users have added themselves from the UI.
      // Looking for the special URL parameter that is added in these cases
      // seems to be more reliable than looking on the filters added to the
      // search request object.
      if (!empty($_GET['facets']) && is_array($_GET['facets'])) {
        $params['p_s_Facets'] = implode(';', $_GET['facets']);
      }

      // Track the page of the search result.
      $params['p_s_Page'] = $search_result->getSearchRequest()->getPage();

      // Track the sort used in the search request.
      if (!empty(ting_search_current_results()->getSearchRequest()->getSorts())) {
        $current_sort = $search_result->getSearchRequest()->getSorts()[0];
        $params['p_s_Sort'] = ting_search_sort_key_from_sort($current_sort);
      }
      else {
        $default_sort = variable_get('ting_search_default_sort', '');
        // If empty string the default "sort" is ranking. If search provider is
        // opensearch we know how to get the actual ranking used. If not we will
        // use a generic 'rank' value for the parameter.
        if ($default_sort === '') {
          $params['p_s_Sort'] = 'rank';
          if (ding_provider_get_provider_module_name('search') === 'opensearch') {
            $params['p_s_Sort'] = variable_get('opensearch_sort_default', 'rank_frequency');
          }
        }
      }

      // Track the ting_field_search profile used in the request. Is the module
      // enablet and is extended search with profiles activated?
      if (module_exists('ting_field_search') && variable_get('ting_field_search_search_style', FALSE)) {
        if ($profile = ting_field_search_get_active_profile()) {
          $params['p_OSSprofile'] = $profile->name;
        }
      }
    }
  }

  if (!empty($params)) {
    ding_webtrekk_add_page_parameters($params);
  }
}

/**
 * Implements hook_views_post_execute().
 *
 * Track internal search results.
 */
function ding_webtrekk_views_post_execute(&$view) {
  // We also check current_path to ensure we're tracking on the correct page.
  // For example, the view is also executed on ting_search search page to show
  // the number of results to the user, if they searched in content instead.
  // See search_backend.inc ctools content type plugin from ting_search.
  if ($view->name == 'ding_multiple_search' && strpos(current_path(), 'search/node') === 0) {
    // This view is loaded 2 times. Prevent from loading params multiple times.
    $loaded = &drupal_static(__FUNCTION__);
    if (!empty($loaded)) {
      return;
    }
    $loaded = TRUE;

    $params = [
      'internalSearch' => array_shift($view->args),
      'numberSearchResults' => $view->total_rows,
    ];

    // If using views pager; track the current search result page here also.
    if (isset($view->query->pager->current_page)) {
      $params['p_s_Page'] = ++$view->query->pager->current_page;
    }

    ding_webtrekk_add_page_parameters($params);
  }
}

/**
 * Implements hook_ding_entity_view().
 */
function ding_webtrekk_ding_entity_view($entity, $view_mode) {
  $entity_path = entity_uri('ting_object', $entity)['path'];

  // The page parametes for the ting object view should only be added on the
  // full page view for the material.
  if ($view_mode == 'full' && current_path() == $entity_path) {
    $params = [
      'p_mat_type' => $entity->getType(),
      'p_mat_indexno' => $entity->getClassification(),
      'p_mat_lang' => $entity->getLanguage(),
      'p_mat_source' => $entity->getAc_source(),
    ];
    ding_webtrekk_add_page_parameters($params);
  }

  // Look for at reserve button on this ding entity and setup a Webtrekk event
  // if present. These could be added in every view_mode and page.
  if (isset($entity->content['ding_entity_buttons'])) {
    foreach (element_children($entity->content['ding_entity_buttons']) as $delta) {
      foreach ($entity->content['ding_entity_buttons'][$delta] as $key => &$button) {
        // Reserve button.
        if (isset($button['#path']) && $button['#path'] == $entity_path . '/reserve') {
          $button['#options']['attributes']['class'][] = 'ding-webtrekk-event';
          $event_data = json_encode([
            'type' => 'e_reserver',
            'contentId' => $entity->getId(),
          ]);
          $button['#options']['attributes']['data-ding-webtrekk-event'] = $event_data;
        }
        // See online button.
        elseif (isset($button['#attributes']) && in_array('button-see-online', $button['#attributes']['class'])) {
          $button['#attributes']['class'][] = 'ding-webtrekk-event';
          $event_data = json_encode([
            'type' => 'e_online',
            'contentId' => $entity->getId(),
          ]);
          $button['#attributes']['data-ding-webtrekk-event'] = $event_data;
        }
      }
    }
  }
}

/**
 * Implements hook_preprocess_ding_entity_rating_display().
 */
function ding_webtrekk_preprocess_ding_entity_rating_display(&$variables) {
  $variables['classes_array'][] = 'ding-webtrekk-rating-event';
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Attached Webtrekk events to the renew loan buttons.
 */
function ding_webtrekk_form_ding_loan_loans_form_alter(&$form, &$form_state) {
  // We'll only attach the renew events if there's loans that can be renewed.
  // Ding loan form checks this and only sets this element if that's the case.
  if (isset($form['actions_container']['select_all'])) {
    return;
  }

  $renew_all = &$form['actions_container']['actions_top']['renew_all'];
  $renew_all['#attributes']['class'][] = 'ding-webtrekk-event';
  $renew_all['#attributes']['data-ding-webtrekk-event'] = json_encode([
    'type' => 'e_forny_alle_materialer',
  ]);

  $renew_selected = &$form['actions_container']['actions_top']['submit_first'];
  $renew_selected['#attributes']['class'][] = 'ding-webtrekk-event';
  $renew_selected['#attributes']['data-ding-webtrekk-event'] = json_encode([
    'type' => 'e_forny_valgte_materialer',
  ]);
}

/**
 * Adds Webtrekk page parameters to the current page.
 *
 * @see ding_webtrekk_preprocess_html().
 */
function ding_webtrekk_add_page_parameters(array $parameters = NULL) {
  $stored_parameters = &drupal_static(__FUNCTION__, array());

  if (isset($parameters)) {
    $stored_parameters = array_merge($stored_parameters, $parameters);
  }

  return $stored_parameters;
}

/**
 * Returns all the Webtrekk page parameteres collected during the request.
 *
 * @see ding_webtrekk_preprocess_html().
 */
function ding_webtrekk_get_page_parameters() {
  $parameters = ding_webtrekk_add_page_parameters();
  // Give other modules a last chance to alter the webtrekk page parameters
  // before they are added to the current page load.
  drupal_alter('ding_webtrekk_page_parameters', $parameters);
  return $parameters;
}

/**
 * Implements hook_process_html().
 *
 * If any Webtrekk page parameters was stored during the request, we'll apply
 * them here. We use this hook since it's run late in the request.
 */
function ding_webtrekk_preprocess_html() {
  $parameters = ding_webtrekk_get_page_parameters();

  $script_lines = array_map(function($key, $value) {
    // We require a non-empty value but would also like to track values such as
    // 0 and '0'. For example if there was 0 search results.
    if (!empty($value) || (string) $value === '0') {
      return "window._ti['$key'] = '$value'";
    }
  }, array_keys($parameters), $parameters);

  // Remove empty values.
  $script_lines = array_filter($script_lines);

  $script_lines = array_merge(
    ['window._ti = window._ti || {}'],
    $script_lines
  );

  $script = implode(";\n", $script_lines);
  drupal_add_js($script, [
    'type' => 'inline',
  ]);

  // Add script that tracks Webtrekk events in client and adds URL parameters
  // to elements which is problematic to handle on the server.
  drupal_add_js(drupal_get_path('module', 'ding_webtrekk') . '/ding_webtrekk.js', array(
    'scope' => 'footer'
  ));
}
